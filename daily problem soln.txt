// HackerEarth November circuits solution
Q1. Find Pairs Partial acceptance
    #include <bits/stdc++.h>
using namespace std;

int binSearchLowerBound(vector<long long> &odd, long long key){
	int l = 0;
	int r = odd.size()-1;
	int index = 0;

	while(l<=r){
		int mid = l+(r-l)/2;
		if(odd[mid]==key){
			index = mid;
			break;
		}
		else if(odd[mid]>key) r = mid-1;
		else l = mid+1;
	}

	while(index>=0 && odd[index]>=key){
		index--;
	}
	index++;
	return index;
}

int binSearchUpperBound(vector<long long> &odd, long long key){
	int l = 0;
	int r = odd.size()-1;
	int n = odd.size();
	int index = r;

	while(l<=r){
		int mid = l+(r-l)/2;
		if(odd[mid]==key){
			index = mid;
			break;
		}
		else if(odd[mid]>key) r = mid-1;
		else l = mid+1;
	}

	while(index<n && odd[index]<=key){
		index++;
	}
	index--;
	return index;
}

int main() {
	long long N,L,R;
	cin>>N>>L>>R;
	vector<long long> arr(N);
	for(int i=0;i<N;i++)
		cin>>arr[i];
	vector<long long> even;
	vector<long long> odd;

	for(auto x:arr){
		if(x&1) odd.push_back(x);
		else even.push_back(x);
	}

	sort(odd.begin(),odd.end()); //O(len(odd)*log(len(odd)))
	sort(even.begin(),even.end()); //O(len(even)*log(len(even)))

	long long ans = 0;
	int idx = 0;
	for(auto x:even){
		if(x>=R) continue;
			int ind = binSearchUpperBound(odd,R-x);
			int ind1 = binSearchLowerBound(odd,L-x);
			if(odd[ind]+x<L) continue;
			if(odd[ind1]+x<L) {
				while(ind1<odd.size() && odd[ind1]<L-x){
					ind1++;
				}
				if(ind1>=odd.size()) ind1--;
			}
			if(odd[ind]+x>R){
				while(ind>=0 && odd[ind]>(R-x)){
					ind--;
				}
				if(ind<0) ind++; 
			}
			ans+=(ind-ind1+1);
		idx++;
	}
	cout<<ans<<'\n';

	return 0;
}

Q2. Bob's Quest
//Did not try it

Q. GFG SHUFFLE ARRAY using xtra space
	void shuffleArray(int arr[],int n)
	{
	    // Your code goes here
	    int mid = n/2;
	    const int midFixed = n/2;
	    vector<int> xtra(n);
	    int l = 0;
	    int i = 0;int j=0;
	    while(l<midFixed && mid<n){
	        xtra[i++] = arr[l++]; 
	        xtra[i++] = arr[mid++];
	    }
	    i=0;
	    for(auto x:xtra){
	        arr[i++] = x;
	    }
	}

	
Q Sum of dependencies in a graph

class Solution {
  public:
    int sumOfDependencies(vector<int> adj[], int V) {
        // code here
        //Don't need to know graph to solve this
        int ans = 0;
        for(int i=0;i<V;i++)
            ans+=adj[i].size();
        
        return ans;
    }
};	


Q. Check whether BST contains Dead End 

class Solution{
  public:
  
    bool helper(Node *node, int MIN, int MAX){
        if(!node) return 0;
        
        if(node->data == MIN and node->data == MAX) return 1;
        
        return helper(node->left, MIN, node->data-1) or helper(node->right, node->data+1, MAX);
    }
    
  
    bool isDeadEnd(Node *root)
    {
        //Your code here
        return helper(root, 1, 1e5);
    }


Q. Number of subarrays with max
    long countSubarrays(int a[], int n, int L, int R)
    {
        // Complete the function
        //Brute force 
        int ans = 0;
        for(int i=0;i<n;i++){
            int ma = a[i];
            for(int j=i;j<n;j++){
                ma = max(ma,a[j]);
                // cout<<ma<<" ";
                if(ma>=L && ma<=R) ans++;
            }
        }
        
        // cout<<"\n";
        
        return ans;
        
    }

Q. Transform to prime
class Solution
{
    public:
    
    int isPrime(int N){
        if(N<2) return 0;
        
        for(int i=2;i*i<=N;i++) if(N%i==0) return 0;
        
        return 1;
    }
    
    
    
    
    
    
    int minNumber(int arr[],int N)
    {
        int sum = 0;
        int arrSum = 0;
        for(int i=0;i<N;i++){
            sum+=arr[i];
        }
        
        arrSum = sum;
        
        if(isPrime(sum)) return 0;
        
        while(!isPrime(sum)){
            sum++;
        }
        
        return sum - arrSum;
    }
};

class Solution {
  public:
    
    int sumReturner(int n){
        int sum = 0;
        while(n){
            sum+=(n%10);
            n/=10;
        }
        return sum;
    }
    
    int factorFinder(int &n){
        int l = 2;
        while(l<=n){
            if(n%l==0){
                n/=l;
                return l;
            }
            l++;
        }
        n=0;
        return 0;
    }
    
    int isPrime(int n){
        for(int i=2;i*i<=n;i++) if(n%i==0) return 0;
        return 1;
    }
  
    int smithNum(int n) {
        
        if(isPrime(n)) return 0; //Since not a composite number
        
        int sumOfDigits = sumReturner(n);
        int sumOfPrimeFactors = 0;
        while(n){
            int tempPrimeFactors = factorFinder(n);
            sumOfPrimeFactors += sumReturner(tempPrimeFactors);
        }
        
        
        return sumOfDigits == sumOfPrimeFactors ? 1 : 0;
        
    }
};

   bool subArrayExists(int arr[], int n)
    {
        //Your code here
        
        //Brute Force
        for(int i=0;i<n;i++) if(arr[i]==0) return 1;
        
        for(int i=0;i<n;i++){
            int temp = 0;
            for(int j=i;j<n;j++){
                temp+=arr[j];
                if(temp==0) return 1;
            }
        }
        
        return 0;
    }

    long maximumSumSubarray(int K, vector<int> &Arr , int N){
        // code here 
        if(N<K) return 0;
        
        int l=0;
        long sum = 0;
        long ans = 0;
        for(int i=0;i<K;i++){
            sum+=Arr[i];
        }
        ans = sum;
        for(int i=K;i<N && l<N;i++){
            sum-=Arr[l];
            sum+=Arr[i];
            l++;
            ans = max(ans,sum);
        }
        return ans;
    }
};

Q. Gold mine Problem


class Solution{
public:
    int dp[1000][1000];
    int help(vector<vector<int> > &M,int currX, int currY, int Msize, int Nsize){
        if(currX<0) return 0;
        if(currX>=Msize || currY>=Nsize){
            return dp[currX][currY]=0;
        }
        if(dp[currX][currY]!=-1) return dp[currX][currY];
        
        if(currX==0) return dp[currX][currY] = M[currX][currY]+max(help(M, currX, currY+1,Msize,Nsize),help(M,currX+1, currY+1,Msize,Nsize));
        
        return dp[currX][currY] = M[currX][currY]+max(max(help(M, currX, currY+1,Msize,Nsize),help(M,currX+1, currY+1,Msize,Nsize)),
                                        
                                    help(M,currX-1,currY+1,Msize,Nsize));
    }
    int maxGold(int n, int m, vector<vector<int>> M)
    {
        // code here
        memset(dp,-1,sizeof(dp));
        
        int Msize = M.size();
        int Nsize = M[0].size();
        
        int ans = 0;
        int temp = 0;
        
        for(int i=0;i<Msize;i++){
            // cout<<
            ans = max(ans,help(M,i,0,Msize,Nsize));
            // cout<<ans<<'\n';
        }
        return ans;
    }
};

Q. Consecutive One's not allowed

class Solution{
public:

    const ll MOD = 1e9+7;
	// #define ll long long
	int chkConsOnes(int n){
	    int temp = 0;
	    int prevTemp = 0;
	    while(n){
	        prevTemp = temp;
	        temp = n%2;
	        n/=2;
	        
	        if(temp==1 && prevTemp == 1) return 1;
	    }
	    
	    return 0;
	}
	
	ll countStrings(int n) {
	    // code here
	    
	    ll ans = 5;
	    
	    ll n1 = 2, n2 = 3;
	    
	    if(n==1) return n1;
	    if(n==2) return n2;
	    if(n==3) return (n1+n2);
	    n-=3;
	    
	    while(n--){
	        n1 = n2;
	        n2 = ans;
	        ans = (n1%MOD+n2%MOD)%MOD;
	    }
	    
	    return ans%MOD;
	}
};


Q. String's count

long long nc1(long long n){
    return n;
}

long long nc2(long long n){
    return ((n)*(n-1))/2;
}


long long nmultiple(long long n){
    return ((n)*(n-1)*(n-2))/2;
}


long long int countStr(long long int n){
    //complete the function here
    if(n==1) return 3;
    
    if(n==2) return 8;
    
    long long ans = 0;
    ans ++;
    ans+=2*nc1(n);
    ans+=3*nc2(n);
    ans+=nmultiple(n);
    
    return ans;
}

Q. Game of XOR
  int gameOfXor(int N , int A[]) {
        // code here
        if(N%2==0) return 0;
        int ans = 0;
        for(int i=0;i<N;i+=2){
            if(i<N) ans^=A[i];
        }
        
        return ans;
    }

Q. Maximum number of meetings 


class Solution{
public:

static   bool myComparison(const pair<pair<int,int>,int> &a,const pair<pair<int,int>,int> &b)
{
       if(a.first.second==b.first.second) return a.first.first<b.first.first;
       return a.first.second<b.first.second;
}
    
    vector<int> maxMeetings(int N,vector<int> &S,vector<int> &F){
        vector<pair<pair<int,int>,int> > meetings;
        for(int i=0;i<N;i++){
            meetings.push_back({{S[i],F[i]},i});
        }
        
        sort(meetings.begin(),meetings.end(),myComparison);
       vector<int> ans;
       ans.push_back(meetings[0].second+1);
       pair<int,int> temp = {meetings[0].first.first,meetings[0].first.second};
       for(int i=1;i<N;i++){
           if(meetings[i].first.first>temp.second){
               ans.push_back(meetings[i].second+1);
               temp = {meetings[i].first.first,meetings[i].first.second};
           }
       }
       
       sort(ans.begin(),ans.end());
       
       return ans;
    }
};


Q. Count Element occurences
   int countOccurence(int arr[], int n, int k) {
        // Your code here
        unordered_map<int,int> mp;
        for(int i=0;i<n;i++) mp[arr[i]]++;
        int ans = 0;
        for(auto x:mp) if(x.second>(n/k)) ans++;
        return ans;
    }


Q. Anti Diagonal traversal of matrix

void printReq(vector<vector<int>> &matrix, vector<vector<int>> &visited, vector<int> &ans,int i, int j,int n){
                while(i<n && j>=0 && !visited[i][j]){
                    visited[i][j]=1;
                    ans.push_back(matrix[i][j]);
                    i++,j--;
                }
    }
  
    vector<int> antiDiagonalPattern(vector<vector<int>> matrix) 
    {
        // Code here
        int n = matrix.size();
        vector<vector<int> > visited(n,vector<int> (n,0));
        vector<int> ans;
        for(int i = 0;i<n;i++){
            for(int j = 0;j<n;j++){
                if(!visited[i][j]){
                    printReq(matrix,visited,ans,i,j,n);
                }
            }
        }
        
        return ans;
    }

Q. Winner of an election

  //Function to return the name of candidate that received maximum votes.
    vector<string> winner(string arr[],int n)
    {
        // Your code here
        // Return the string containing the name and an integer
        // representing the number of votes the winning candidate got
        
        string temp = "";
        int ans = 0;
        for(int i = 0; i<100000;i++) temp+='z';
        
        unordered_map<string,int> mp;
        for(int i=0;i<n;i++){
            mp[arr[i]]++;
        }
        for(auto x:mp){
            if(x.second > ans){
                ans = x.second;
                temp = x.first;
            }
            else if(x.second == ans){
                if(x.first<temp){
                    temp = x.first;
                }
            }
        }
        
        return {temp, to_string(ans)};
    }

Q. New Year resolution dp 140 testcases attempt1

    int help1(int index,int coins[],int N,int sum,vector<vector<int> > &dp){
        
        if(index>=N){
            if((sum%20 == 0 || sum%24==0 || sum == 2024) && sum!=0) return 1;
            return 0;
        }
        
        if(sum>2024) return 0;
        
        if((sum%20 == 0 || sum%24==0 || sum == 2024) && sum!=0) return dp[sum][coins[index]] = 1;
        
        
        if(dp[sum][coins[index]]!=-1) return dp[sum][coins[index]];
        
        return dp[sum][coins[index]]
             = help1(index+1,coins,N,sum+coins[index],dp) || help1(index+1,coins,N,sum,dp);
    }
    
    int isPossible(int N , int coins[]) 
    {
        int sum = 0;
        int index = 0;
        vector<vector<int> > dp(2024,vector<int>(2024,-1));
        return help1(index,coins,N,sum,dp);
    }


Q. Array Pair sum divisibility problem

 bool canPair(vector<int> nums, int k) {
        // Handling base cases
        int n = nums.size();
        if(nums.size()%2!=0) return 0;
        
        int sum = 0;
        for(int i=0;i<nums.size();i++){
            sum+=nums[i];
        }
        if(sum%k!=0) return 0;
        
        // will be writing mainCode here
        //first going brute force
        vector<pair<int,int> > takenOrNot;
        for(auto x:nums){
            takenOrNot.push_back({x,0});
        }
        
        for(int i=0;i<n;i++){
            int temp = 1;
            int temp1 = 1;
            if(!takenOrNot[i].second){
                temp1 = 0;
            for(int j=i;j<n;j++){
                if((nums[i]+nums[j])%k==0 && !takenOrNot[j].second){
                    takenOrNot[j].second = 1;
                    takenOrNot[i].second = 1;
                    temp = 0;
                    break;
                }
            }   
            }
            if(temp && !temp1) return 0;
        }
        
        for(auto x:takenOrNot){
            if(x.second != 1) return 0;
        }
        
        return 1;
    }
};


Find element occuring once when (Google)

class Solution {
  public:
    int singleElement(int arr[] ,int N) {
        // code here
        unordered_map<int,int> mp;
        for(int i=0;i<N;i++){
            mp[arr[i]]++;
        }
        for(auto x:mp){
            if(x.second == 1) return x.first;
        }
        
        return -1;
    }
};


Q. Techfest and the queue 

  BRUTE FORCE

    int helper(int n){
        int sum = 0;
        int l = 2;
        int cnt = 0;
        
        while(n && n>=l){
            if(n%l==0){
                n/=l;
                sum++;
            }
            else{
                l++;
            }
        }
        return sum;
    }

	int sumOfPowers(int a, int b){
	    // Code here
	    int ans = 0;
	    for(int i=a;i<=b;i++) ans+=helper(i);
	    return ans;
	}


O(Nsqrt(N))

    
    int isPrime(int n){
        for(int i=2;i*i<=n;i++){
            if(n%i==0) return i;
        }
        
        return -1;
    }
    
    int helper(int n){
        int sum = 0;
        int l = 2;
        int cnt = 0;
        
        if(n<2) return 0;
        
        while(n>0){
            int isPrimeResp = isPrime(n);
            if(isPrimeResp == -1) return ++sum;
            else{
                n/=isPrimeResp;
                sum++;
            }
        }
        return sum;
    }

	int sumOfPowers(int a, int b){
	    // Code here
	    int ans = 0;
	    for(int i=a;i<=b;i++) ans+=helper(i);
	    return ans;
	}



Q. Merge two sorted linkedlist in reverse order
class Solution
{
    public:
    
    
    struct Node * reverseList(Node* list){
        
        if(!list && !list->next) return list;
        
        Node* prev = NULL;
        Node* curr = list;
        Node* forw = list->next;
        
        while(forw){
            curr->next = prev;
            prev = curr;
            curr = forw;
            forw = forw -> next;
        }
        
        curr->next = prev;
        
        return curr;
        
    }
    
    
    struct Node * mergeResult(Node *node1,Node *node2)
    {
        // your code goes here
        // int data = node1->data > node2->data ? node2->data:node1->data;
        
        
        Node* ans = new Node();
        Node* res = ans;
        while(node1 && node2){
            Node* temp=new Node();
            if(node1->data < node2->data){
                ans->data = node1->data;
                ans->next = temp;
                node1 = node1->next;
                ans = ans->next;
            }else{
                ans->data = node2->data;
                ans->next = temp;
                node2 = node2->next;
                ans = ans->next;
            }
        }
        while(node1){
                Node* temp=new Node();
                ans->data = node1->data;
                ans->next = temp;
                node1 = node1->next;
                ans = ans->next;
        }
        while(node2){
                Node* temp = new Node();
                ans->data = node2->data;
                ans->next = temp;
                node2 = node2->next;
                ans = ans->next;
        }
        
        Node* result = reverseList(res);
        
        
        return result?result->next:result;
    }  
};

Q. Search pattern KMP algorithm
//BRUTE FORCE 1070 / 1120

    vector <int> search(string pat, string txt)
        {
            //code here
            vector<int> ans;
            int n = pat.length();
            for(int i=0;i<txt.size();i++){
                if(pat==txt.substr(i,n)){
                    ans.push_back(i+1);
                }
            }
            
            if(ans.size()>0) return ans;
            
            return {-1};
        }

//I GUESS BAD TEST CASE DESING SHOULD INCLUDE aaaaa.. 10^5
  aaaaa^10^4

 public:
        vector <int> search(string pat, string txt)
        {
            //code here
            vector<int> ans;
            int n = pat.length();
            for(int i=0;i<txt.size();i++){
                if(pat[0]==txt[i]){
                    if(pat==txt.substr(i,n)){
                        ans.push_back(i+1);
                    }   
                }
            }
            
            if(ans.size()>0) return ans;
            
            return {-1};
        }

Q. Longest subarray with sum 

//BRUTE FORCE X can be made O(n*n) using dp but not recommended

    void help(int arr[],int index,int n,int k,int &ans,int currAns, int sum,int included){
        
        if(included && index<=n) currAns++;
        
        if(sum%k==0 && index<=n){
            // cout<<currAns<<' '<<sum<<" "<<index<<"Entered\n";
            ans = max(ans,currAns);
        }
        
        if(index>=n) return ;
        
        help(arr,index+1,n,k,ans,currAns,sum+arr[index],1);//included
        help(arr,index+1,n,k,ans,currAns,sum,0);//excluded
        
    }

	int longSubarrWthSumDivByK(int arr[], int n, int k)
	{
	        int ans = 0;
	        help(arr,1,n,k,ans,0,arr[0],1);
	        help(arr,1,n,k,ans,0,0,0);
	        return ans;
	}

Q. Reverse first k elements of queue

Solution using stack
class Solution
{
    public:
    
    // Function to reverse first k elements of a queue.
    queue<int> modifyQueue(queue<int> q, int k) {
        // add code here.
        stack<int> auxQueue;
        queue<int> ans;
        for(int i=0;i<k && !q.empty();i++){
            auxQueue.push(q.front());
            q.pop();
        }
        
        while(!auxQueue.empty()){
            ans.push(auxQueue.top());
            auxQueue.pop();
        }
        
        while(!q.empty()){
            ans.push(q.front());
            q.pop();
        }
        
        return ans;
    }
};

Q. Insertion sort on a linked list

class Solution
{
    public:
    
    void printHead(Node* head){
        while(head){
            cout<<head->data<<" ";
            head = head-> next;
        }
        cout<<"\n";
    }
    
    Node* insertAtPlace(Node* head, int data){
        Node* tobeInserted = new Node(data);
        Node* res = head;
        
        if(!head){
            head = tobeInserted;
            return head;
        }
        
        
        if(!head->next){
            if(head->data<tobeInserted->data){
                head->next = tobeInserted;
                return head;
            }
            else{
                tobeInserted->next = head;
                head = tobeInserted;
                return head;
            }
        }
        
        
        
        while(head && head->next && head->next->data < data){
            // cout<<head->data<<" ";
            head = head->next;
        }
        
        if(head->next && head->next->data>=data){
            tobeInserted->next = head->next;
            head->next = tobeInserted;
        }
        else if(head->next && head->next->data<data){
            head = head->next;
            head->next = tobeInserted;
        }
        else if(!head->next){
            head->next = tobeInserted;
        }
        
        return res;
        
        
    }
    
    Node* insertionSort(struct Node* head_ref)
    {
        if(!head_ref || !head_ref->next) return head_ref;
        //code here
        Node* ans = new Node(head_ref->data);
        
        // head_ref = head_ref->next;
              
        while(head_ref){
            // cout<<head_ref->data<<"\n";
            ans =  insertAtPlace(ans,head_ref->data);
            // printHead(ans);
            head_ref = head_ref->next;
        }
        // cout<<"\n";
        
        //remove head
        ans = ans->next;
        
        return ans;
    }
    
};


Q. Find duplicate rows in a binary matrix

class Solution
{   
    
    int isEqual(vector<int> first, vector<int> second){
        if(first.size()!=second.size()) return 0;
        for(int i=0;i<first.size();i++){
            if(first[i]!=second[i]) return 0;
        }
        return 1;
    }
    
    public:
    vector<int> repeatedRows(vector<vector<int>> &matrix, int M, int N) 
    { 
        vector<int> ans;
        vector<vector<int> > storage;
        int l = 0;
        for(vector<int> a:matrix){
          if(storage.size()==0){
              storage.push_back(a);
          }
          else{
              int flag = 0;
              for(int i=0;i<storage.size();i++){
                  if(isEqual(storage[i],a)){
                      ans.push_back(l);
                      flag = 1;
                      break;
                  }
              }
              storage.push_back(a);
          }
          l++;
        }
        
        return ans;
    } 
};


Q. Sequence of sequence	
    int help(int currLen, int &reqLen, int currNum,int &m){
        if(currNum>m) return 0;
        if(currLen == reqLen) return 1;
        int temp = currNum*2;
        int res = 0;
        for(int i=temp;i<=m;i++){
            res += help(currLen+1,reqLen,i,m);
        }
        return res;
    }
    
    int numberSequence(int m, int n){
        // code here
        int ans = 0;
        for(int i=0;i<m;i++){
            ans+=help(1,n,i+1,m);
        }
        
        return ans;
    }

Q. All unique permutations
//BRUTE FORCE PARTIAL ACC

class Solution {
  public:
    
    void help(vector<pair<int,int> > visited,set<vector<int>> &ans,int index,vector<int> currPerm,int &n){
        if(index==n && currPerm.size()==n){
            ans.insert(currPerm);
            return ;
        }
        if(index>n){
            return ;
        }
        for(int i=0;i<n;i++){
            if(!visited[i].second){
                visited[i].second = 1;
                currPerm.push_back(visited[i].first);
                help(visited,ans,index+1,currPerm,n);
                currPerm.pop_back();
                visited[i].second = 0;
                help(visited,ans,index+1,currPerm,n);
            }
        }
    }
  
    vector<vector<int>> uniquePerms(vector<int> &arr ,int n) {
        // code here
        set<vector<int> > ans;
        vector<vector<int> > res;
        vector<pair<int,int> > visited;
        
        
        for(int i=0;i<n;i++){
            visited.push_back({arr[i],0});
        }
        
        sort(visited.begin(),visited.end());
        help(visited,ans,0,{},n);
      
        
        for(auto x:ans){
            res.push_back(x);
        }
        
        return res;
    }
};

Accepted

class Solution {
  public:
    
    void help(vector<pair<int,int> > visited,set<vector<int>> &ans,int index,vector<int> currPerm,int &n){
        if(index==n && currPerm.size()==n){
            ans.insert(currPerm);
            return ;
        }
        
        
        if(index>n){
            return ;
        }
        
        if(index!=currPerm.size()) return ;
        
        for(int i=0;i<n;i++){
            if(!visited[i].second){
                visited[i].second = 1;
                currPerm.push_back(visited[i].first);
                help(visited,ans,index+1,currPerm,n);
                currPerm.pop_back();
                visited[i].second = 0;
                help(visited,ans,index+1,currPerm,n);
            }
        }
    }
  
    vector<vector<int>> uniquePerms(vector<int> &arr ,int n) {
        // code here
        set<vector<int> > ans;
        vector<vector<int> > res;
        vector<pair<int,int> > visited;
        
        
        for(int i=0;i<n;i++){
            visited.push_back({arr[i],0});
        }
        
        sort(visited.begin(),visited.end());
        help(visited,ans,0,{},n);
      
        
        for(auto x:ans){
            res.push_back(x);
        }
        
        return res;
    }
};

class Solution{
public:	

    int isEqualInFREQTerms(vector<int> temp){
        int chk = temp[0];
        for(int i=0;i<temp.size();i++){
            if(chk!=temp[i] && (chk!=0 && temp[i]!=0)) return 0;
            chk = temp[i];
        }
        
        set<int> st1;
        for(auto x:temp) st1.insert(x);
        
        if(st1.size()>2) return 0;
        
        return 1;
    }
    
	bool sameFreq(string s)
	{
	    // code here 
	    unordered_map<char,int> mp;
	    for(auto x:s){
	        mp[x]++;
	    }
	    
	    vector<int> store;
	    for(auto x:mp) store.push_back(x.second);
	    int n = store.size();
	    
	    if(isEqualInFREQTerms(store)) return 1;
	    
	    for(int i = 0;i<n;i++){
	        store[i]--;
	       // cout<<store[i]<<" ";
	        if(isEqualInFREQTerms(store)) return 1;
	        store[i]++;
	    }
	    
	    return 0;
	}
};

class Solution{
public:	
    int isEqual(int arr[]){
         int flag = 0;int temp=0;
        for(int i=0;i<26;i++){
            if(arr[i]==0) continue;
            if(temp==0){
                temp=arr[i];
            }
            if(arr[i]!=temp) return 0;
        }
        
        return 1;
    }
	bool sameFreq(string s)
	{
	    int freq[26] = {0};
	    for(auto x:s) freq[x-'a']++;
	    int n = s.length();
	    
	    if(isEqual(freq)) return 1;
	    
	    for(int i=0;i<n;i++){
	        if(freq[s[i]-'a']==0) continue;
	        freq[s[i]-'a']--;
	        if(isEqual(freq)) return 1;
	        freq[s[i]-'a']++;
	    }
	    
	    return 0;
 }

Q. Validate an Ipv4 address
        string clipLeadingZeroes(string eachIpvSegment){
            string clippedString = "";
            for(auto x:eachIpvSegment){
                if(x=='0') continue;
                clippedString+=x;
            }
            return (clippedString.length() == 0 && eachIpvSegment.length()>0) ? "0":clippedString;
        }
    
        
        int startHelping(string eachIpvSegment){
           if(eachIpvSegment.length()==0) return 0;
           if(eachIpvSegment.length()>3) return 0;
           if(eachIpvSegment.length()>1 && eachIpvSegment[0]=='0') return 0;
           for(int i=0;i<eachIpvSegment.length();i++){
               if(eachIpvSegment[i]>='0' && eachIpvSegment[i]<='9') continue;
               return 0;
           }
           string segmentClone = clipLeadingZeroes(eachIpvSegment);
           int help = (stoi(segmentClone)<=255) ? 1 : 0;
           return help;
        }
        
        int isValid(string s) {
            string eachIpvSegment = "";
            int patience = 0;int countOfDots = 0;
            for(int i=0;i<s.length();i++){
                if(s[i]=='.' && countOfDots<3){
                    patience += startHelping(eachIpvSegment);
                    eachIpvSegment = "";
                    countOfDots++;
                    continue;
                }
                eachIpvSegment+=s[i];
            }
            patience+=startHelping(eachIpvSegment);
            return patience == 4;
        }

Q. Fractional Knapsack

  static bool customCompare(Item a, Item b){
        return (a.value/(double)a.weight) >= (b.value/(double)b.weight);
    }
    //Function to get the maximum total value in the knapsack.
    double fractionalKnapsack(int W, Item arr[], int n)
    {
        sort(arr,arr+n,customCompare);
        double ans = 0;int index = 0;
        while(W && index<n){
            if(W>=arr[index].weight){
                W-=arr[index].weight;
                ans+=arr[index].value;
                index++;
            }
            else{
              ans+=(((double)arr[index].value*W)/(double)arr[index].weight);
              W=0;
            }
        }
        
        return ans;
    }
Q. Check if string is rotated by 2 places

  bool isRotated(string str1, string str2)
    {
        //right rotate by 2
        int n = str1.size();
        string rCopystr1 = "";string lCopystr1(n,'\0');
        for(int i=0;i<n;i++){
            rCopystr1+=(str1[(i+2)%n]);
            lCopystr1[(i+2)%n] = str1[i];
        }
        
        if(rCopystr1==str2 || lCopystr1==str2) return true;
        return false;
    }

Q. Multiply two strings TLE

  public:
    //Initially cut the issue of leading zeroes
    string trimString(string s1){
        int l = 0;
        while(l<s1.size()){
            if(s1[l]!='0') break;
            l++;
        }
        return s1.substr(l,s1.size());
    }
    //Try to add two strings here
    string addTwoStrings(string s1, string s2){
        string res = "";
        int l = s1.length()-1;
        int r = s2.length()-1;
        int carry = 0;
        while(l>=0 && r>=0){
            int c = (s1[l--]-'0'+s2[r--]-'0'+carry);
            res+=to_string(c%10);
            carry = c/10;
        }
        
        while(l>=0){
            int c = (s1[l--]-'0'+carry);
            res+=to_string(c%10);
            carry = c/10;
        }
        
        
        while(r>=0){
            int c = (s2[r--]-'0'+carry);
            res+=to_string(c%10);
            carry = c/10;
        }
        
        if(carry)
            res+=to_string(carry);
            
        reverse(res.begin(),res.end());    
        return res;
    }
    
    string multiplyAssist(string s1, char multiplyer){
        int l = s1.length()-1;int carry = 0;string res = "";
        while(l>=0){
            int c = ((s1[l--]-'0')*(multiplyer-'0'))+carry;
            carry = c/10;
            res += to_string(c%10);
        }
        
        if(carry) res += to_string(carry);
        reverse(res.begin(),res.end());
        return res;
    }
    
    //main method
    string multiplyStrings(string s1, string s2) {
        
    //   removeSigns
        int a = 1;
        if(s1[0]=='-'){
            s1 = s1.substr(1,s1.length());
            a*=-1;
        }
        
        if(s2[0]=='-'){
            s2 = s2.substr(1,s2.length());
            a*=-1;
        }
       //Your code here
       s1 = trimString(s1);
       s2 = trimString(s2);
       
       vector<string> storage;int l = 0;
       string ans = "";
       for(int i=s2.size()-1;i>=0;i--){
           string temp = multiplyAssist(s1,s2[i]);
           for(int j=0;j<l;j++) temp+="0"; 
           l++;
           ans = addTwoStrings(ans,temp);
       }
       
       string res = ((a == -1 && ans.length()>0) ? "-"+ans : ans); 
       
       return res.length()==0? "0":res;
    }

Q. Isomorphic Strings
    bool areIsomorphic(string str1, string str2)
    {
        if(str1.length()!=str2.length()) return false;
        
        //we will create a map of chars and check what values it might store
        //Can also be done using frequency array
        unordered_map<char,char> mpStr1;
        unordered_map<char,char> mpStr2;
        
        for(int i = 0;i<str1.size();i++){
            if(mpStr1.find(str1[i])!=mpStr1.end()){
                if(mpStr1[str1[i]]!=str2[i]) return false;
            }
            if(mpStr2.find(str2[i])!=mpStr2.end()){
                if(mpStr2[str2[i]]!=str1[i]) return false;
            }
            mpStr1[str1[i]]=str2[i];
            mpStr2[str2[i]]=str1[i];//reverse mapping
        }
        
        return true;
        
    }
Q. Implement ATOI
  int atoi(string str) {
        //Your code here
        int ans = 0;int sign = 1;
        if(str[0]=='-'){
            str = str.substr(1,str.length());
            sign*=-1;
        } 
        for(int i=0;i<str.length();i++){
            if(str[i]<'0' || str[i]>'9') return -1;
            ans = ans*10 + str[i]-'0';
        }
        return sign*ans;
    }
Q. Non repeating char
  char nonrepeatingCharacter(string S)
    {
       //Your code here
       char ans = 36;
       int freq[26]={0};
       for(auto x:S){
           freq[x-'a']++;
       }
       
       for(auto x:S){
           if(freq[x-'a']==1) return x;
       }
       
       return ans;
    }

Q. Recursively remove adjacent chars O(n*n) where n = length of str [TLE 256/358]

    int containsAdjacentDuplicate(string s){
        for(int i=0;i<s.length()-1;i++){
            if(s[i]==s[i+1]) return 1;
        }
        
        return 0;
    }
    
    string helpToRemove(string s){
        string resp = "";int flag = 0;
        unordered_map<int,int> indices;
        for(int i=0;i<s.length()-1;i++){
            if(s[i]==s[i+1]){
                indices[i]=1;
                indices[i+1]=1;
            }
        }
        for(int i = 0;i<s.length();i++){
            if(indices.find(i)==indices.end()) resp+=s[i];
        }
        return resp;
    }
    
    string rremove(string s){
      while(containsAdjacentDuplicate(s) && s.length()>0){
          s = helpToRemove(s);
      }
      return s;
    }

[ACCEPTED]
    string removeAdjacent(string s, string str){
        for(int i=0;i<s.size();i++){
            if(s[i]!=s[i-1] && s[i]!=s[i+1]){
                str += s[i];
            }
        }
        
        if(s.size()==str.size()) return str;
        
        return removeAdjacent(str,"");
    }

    string rremove(string s){
        string res = removeAdjacent(s,"");
        return res;
    }

Q. Longest k unique chars substring [TLE 35/1111]
int uniqueChars(int arr[]){
        int uniqueChars = 0;
        for(int i=0;i<26;i++){
            if(arr[i]) uniqueChars++;
        }
        return uniqueChars;
    }
  
    int longestKSubstr(string s, int k) {
        //First will go for the brute force approach
        int ans = 0;
        for(int i=0;i<s.length();i++){
            int localFreq[26] = {0};
            for(int j = i;j<s.length();j++){
                localFreq[s[j]-'a']++;
                if(uniqueChars(localFreq)==k){
                    ans = max(ans,j-i+1);
                }
            }
        }
        
        return ans==0 ? -1 : ans;
    }

Q. Minimum indexed character
    int minIndexChar(string str, string patt)
    {
        // Your code here
        int freq[26]={0};
        for(auto x:patt) freq[x-'a']++;
        
        for(int i=0;i<str.length();i++){
            if(freq[str[i]-'a']) return i;
        }
        
        return -1;
    }
Q. Count Digit Groupings [EDITORIAL]
	vector<vector<int> > dp;
	
	int countGroups(int position, int previous_sum, int length, string num){
	    if(position == length) return 1;
	    
	    if(dp[position][previous_sum]!=-1) return dp[position][previous_sum];
	    
	    dp[position][previous_sum] = 0;
	    int res = 0;
	    int sum = 0;
	    
	    for(int i = position; i<length; i++){
	        sum+=(num[i]-'0');
	        if(sum>=previous_sum) res+=countGroups(i+1,sum,length,num);
	    }
	    
	    dp[position][previous_sum] = res;
	    
	    return res;
	}
	
	int TotalCount(string str){
	    // Code here
	    int n = str.size();
	    dp.assign(n,vector<int>(n*8+1,-1));
	    return countGroups(0,0,n,str);
	}

LCS of three strings
brute force recursive TLE [11 cases]
      string dp[100][100];
        
        string LCSof2(string A, string B, int n1, int n2,string ans){
            if(n1<0 || n2<0) return ans;
            
            // if(dp[n1][n2]!= "$") return dp[n1][n2];
            
            
            if(A[n1]==B[n2]){
                // cout<<ans<<'\n';
                return dp[n1][n2] = LCSof2(A,B,n1-1,n2-1,ans+A[n1]);
            } 
            
            string one = LCSof2(A,B,n1-1,n2,ans);
            string two = LCSof2(A,B,n1,n2-1,ans);
            
            if(one.length()>two.length()) return dp[n1][n2] = one;
            
            return dp[n1][n2]=two;
        }
        
        string trim(string a){
            int l = 0;
            string res = "";
            while(a[l]==' ' && l<a.length()){
                l++;
            }
            return a.substr(l,a.size());
        }

        int LCSof3 (string A, string B, string C, int n1, int n2, int n3)
        {
            // your code here
            for(int i=0;i<100;i++){
                for(int j=0;j<100;j++){
                    dp[i][j] = "$";
                }
            }
            
            string l1 = LCSof2(A,B,n1-1,n2-1,"");
            reverse(l1.begin(),l1.end());
            // cout<<l1<<'\n';
            string l2 = LCSof2(l1,C,l1.length()-1,n3-1,"");
            // l2 = trim(l2);
            return l2.size();
        }

Optimised
       int LCSof3Help(string A, string B,string C, int n1, int n2, int n3,vector<vector<vector<int> > > &dp){
            if(n1<0 || n2<0 || n3<0){
                return 0;
            }
            
            if(dp[n1][n2][n3]!=-1) return dp[n1][n2][n3];
            
            if(A[n1]==B[n2] && B[n2]==C[n3]) return dp[n1][n2][n3] = 1+LCSof3Help(A,B,C,n1-1,n2-1,n3-1,dp);
            
            int one = LCSof3Help(A,B,C,n1-1,n2,n3,dp);
            int two = LCSof3Help(A,B,C,n1,n2-1,n3,dp);
            int three = LCSof3Help(A,B,C,n1,n2,n3-1,dp);
            int four = LCSof3Help(A,B,C,n1-1,n2-1,n3,dp);
            int five = LCSof3Help(A,B,C,n1-1,n2,n3-1,dp);
            int six = LCSof3Help(A,B,C,n1,n2-1,n3-1,dp);
            
            vector<int> tempSort;
            tempSort.push_back(one);
            tempSort.push_back(two);
            tempSort.push_back(three);
            tempSort.push_back(four);
            tempSort.push_back(five);
            tempSort.push_back(six);
            
            sort(tempSort.begin(),tempSort.end());
            
            return dp[n1][n2][n3] = tempSort[tempSort.size()-1];
        
        }
        
        int LCSof3 (string A, string B, string C, int n1, int n2, int n3)
        {
    vector<vector<vector<int> > > dp(
        25, vector<vector<int> >(25, vector<int>(25,-1)));

            return LCSof3Help(A,B,C,n1-1,n2-1,n3-1,dp);
        }
Q. Count number of substrings brute force
  
    bool uniqueDetection(int arr[],int k){
        int cnt = 0;
        for(int i=0;i<26;i++){
            if(arr[i]) cnt++;
        }
        return cnt==k;
    }
    
  
    long long int substrCount (string s, int k) {
    	//BRUTE FORCE
    	int ans = 0;
    	for(int i=0;i<s.length();i++){
    	    string temp = "";
    	    int freq[26]={0};
    	    for(int j=i;j<s.length();j++){
    	        freq[s[j]-'a']++;
    	        if(uniqueDetection(freq,k)) ans++;
    	    }
    	}
    	
    	return ans;
    }

Q. second most repeated string
   string secFrequent (string arr[], int n)
    {
        //code here.
        unordered_map<string,int> mp;
        for(int i=0;i<n;i++){
            mp[arr[i]]++;
        }
        vector<pair<int,string>> ordinaryStorage;
        for(auto x:mp){
            ordinaryStorage.push_back({x.second,x.first});
        }
        sort(ordinaryStorage.begin(),ordinaryStorage.end());
        return ordinaryStorage[ordinaryStorage.size()-2].second;
    }

Q. Reverse words in a string
    
    void reverseArray(vector<string> &arr){
        int l = 0;int r = arr.size()-1;
        while(l<=r){
            swap(arr[l++],arr[r--]);
        }
    }
    //Function to reverse words in a given string.
    string reverseWords(string S) 
    { 
        vector<string> arr;
        string temp = "";
        for(int i=0;i<S.length();i++){
            if(S[i]=='.')
            {
                arr.push_back(temp);
                temp = "";
                continue;
            }
            temp+=S[i];
        }
        
        if(temp.length()>0) arr.push_back(temp);
        
        reverseArray(arr);
        S="";
        for(int i=0;i<arr.size();i++){
            S+=(arr[i]+'.');
        }
        S.pop_back();
        
        return S;
    } 

Q. Longest distinct character string 
int longestSubstrDistinctChars (string S)
{
    int l = 0;int r = 0;int n = S.length();
    int ans = 0;
    for(int i = 0;i<n;i++){
        int freq[26] = {0};int len = 0;
        for(int j=i;j<n;j++){ //the inner loop will run atmost 26 times as there are
            freq[S[j]-'a']++; //maximum 26 distinct characters otherwise will repeat
            if(freq[S[j]-'a']>1){
                break;
            }
            len++;
            ans = max(ans,len);
        }
    }
    return ans;
}

Q. Panagram checking
   bool checkPangram (string s) {
        // your code here
        transform(s.begin(),s.end(),s.begin(),::toupper);
        int freq[26]={0};
        for(auto x:s){
            if(x<='Z' && x>='A') freq[x-'A']++;
        }
        for(int i=0;i<26;i++) if(!freq[i]) return 0;
        return 1;
    }
    bool checkPangram (string s) {
        int freqCap[26]={0};
        int freqLow[26]={0};
        for(auto x:s){
            if(x<='Z' && x>='A'){
                freqCap[x-'A']++;
                freqLow[x-'A']++;
            }
            else if(x<='z' && x>='a'){
                freqLow[x-'a']++;
                freqCap[x-'a']++;
            }
        }
        
        for(int i=0;i<26;i++){
            // cout<<freqCap[i]<<' '<<freqLow[i]<<'\n';
            if(!freqCap[i] || !freqLow[i]) return 0;
        }
        
        return 1;
    }

  int getNthFromLast(Node *head, int n)
    {
        //Using two ponter
        Node* ptr = head;
        while(n-- && ptr){
            ptr = ptr->next;
        }
    
        if(n!=-1) return -1;
        
        while(ptr){
            ptr = ptr->next;
            head = head->next;
        }
        
        return head->data;
    }

Q. Implement ATOI

    string trimWhiteSpaces(string s){
        int l = 0; string res = "";
        while(s[l]==' '){
            l++;
        }
        int r= s.length()-1;
        while(s[r]==' '){
            r--;
        }
        return s.substr(l,(r-l+1));
    }
    
    int mainATOIlogic(string s){
        int ans = 0;
        for(int i=0;i<s.length();i++){
            ans = ans*10+(s[i]-'0');
        }
        return ans;
    }
    
    int detectALLInts(string s){
        for(int i=0;i<s.length();i++){
            if(s[i]>='0' && s[i]<='9') continue;
            else return 0;
        }
        return 1;
    }
    
    int atoi(string s) {
        //Your code here
        int flag = 1;
        s = trimWhiteSpaces(s);
        
        
        if(s[0]=='-'){
            flag*=-1;
            s=s.substr(1,s.length());
        }
        
        if(!detectALLInts(s)) return -1;
        
        int res = mainATOIlogic(s);
        
        return flag*res;
    }
};


    void removeLoop(Node* fast, Node* head){
        Node* ptr = head;
        while(head!=fast->next){
            fast = fast->next;
            head = head->next;
        }
        
        fast->next = NULL;
    }
    
    int detectLoop(Node *head){
        if(!head || !head->next) return 0;
        Node* slow = head;
        Node* fast = head->next;
        while(slow && fast && fast->next){
            if(fast == slow) {
                removeLoop(fast, head);
                return 1;
            }
            fast = fast->next->next;
            slow = slow->next;
        }
        return 0;
    }
    //Function to remove a loop in the linked list.
    void removeLoop(Node* head)
    {
        detectLoop(head);
    }

Q. Detect Loop in LL(Linked List)
    
    bool detectLoop(Node* head)
    {
        if(!head || !head->next) return false;
        
        Node* slow = head;
        Node* fast = head->next;
        while(slow && fast && fast->next){
            if(fast == slow) return 1;
            slow = slow -> next;
            fast = fast ->next ->next;
        }
        
        return 0;
    }

Q. Check if LinkedList is a palindrome
   int palin(vector<int> &palinStore){
        int l = 0; int r = palinStore.size()-1;
        while(l<r){
            if(palinStore[l++]!=palinStore[r--]) return 0;
        }
        return 1;
    }
   
    bool isPalindrome(Node *head)
    {
       vector<int> palinStore;
       while(head){
           palinStore.push_back(head->data);
           head = head->next;
       }
       return palin(palinStore);
    }

Q. Remove duplicate elements from sorted LL
Node *removeDuplicates(Node *head)
{
 // your code goes here
    Node *ptr = head;
    if(!ptr || !ptr->next) return ptr;
    
    while(ptr->next){
        if(ptr->data == ptr->next->data){
            ptr->next = ptr->next->next;
        }
        else{
            ptr = ptr->next;
        }
    }
    
    return head;
}

Q. Intersection point

int intersectPoint(Node* head1, Node* head2)
{
    // BRUTE FORCE
    while(head1){
        Node* ptr = head2;
        while(ptr){
            if(ptr == head1) return ptr->data; //Assuming only 1 common node
            ptr = ptr->next;
        }
        head1 = head1->next;
    }
    
    return -1;
}
int interSection(Node* small, Node* large, int diff){
    while(diff--){
        large = large->next;
    }
    
    while(small && large){
        if(small == large) return large->data;
        small = small->next;
        large = large->next;
    }
    
    return -1;
}

//Function to find intersection point in Y shaped Linked Lists.
int intersectPoint(Node* head1, Node* head2)
{
    // BRUTE FORCE
   int lenHead1 = calculateLength(head1);
   int lenHead2 = calculateLength(head2);
   
   return lenHead1 > lenHead2 ? interSection(head2,head1,(lenHead1-lenHead2)) : interSection(head1,head2,(lenHead2-lenHead1));
    
}

Q. Add two numbers represented by Linked Lists


class Solution
{
    public:
    
    Node* insertAtHead(Node* currentHead,int data){
        Node* newHead = new Node(data);
        newHead->next = currentHead;
        currentHead = newHead;
        return currentHead;
    }
    
    Node* reverseLL(Node* head){
        if(!head || !head->next) return head;
        Node* prev = NULL;
        Node* curr = head;
        Node* forw = head->next;
        while(forw){
            curr->next = prev;
            prev = curr;
            curr = forw;
            forw = forw->next;
        }
        curr->next = prev;
        return curr;
    }
    
    void print(Node* head){
        while(head){
            cout<<head->data<<' ';
            head = head->next;
        }
    }
    
    Node* trimLastZero(Node* head){
        if(!head || !head->next) return NULL;
        Node* ptr = head;
        while(head->next->next){
            head = head->next;
        }
        head->next = head->next->next;
        return ptr;
    }
    //Function to add two numbers represented by linked list.
    struct Node* addTwoLists(struct Node* first, struct Node* second)
    {
        first = reverseLL(first);
        second = reverseLL(second);
        Node* ans = new Node(0);
        int carry = 0;
        while(first && second){
            int data = (first->data+second->data+carry)%10;
            carry = (first->data+second->data+carry)/10;
            ans = insertAtHead(ans,data);
            first = first->next;
            second = second->next;
        }
        
        while(first){
            int data = (first->data+carry)%10;
            carry = (first->data+carry)/10;
            ans = insertAtHead(ans,data);
            first = first->next;
        }
        
        while(second){
            int data = (second->data+carry)%10;
            carry = (second->data+carry)/10;
            ans = insertAtHead(ans,data);
            second = second->next;
        }
        
        if(carry) ans = insertAtHead(ans,carry);
        
        return trimLastZero(ans);
    }
};